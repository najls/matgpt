<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="utf-8">
    <meta name="author" content="Nils Persson">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <title>MatGPT</title>

    <style>
        * { box-sizing: border-box }
        html { scroll-behavior: smooth }
        body {
            background-color: #212121;
            color: white;
            font-family: Verdana, Geneva, Tahoma, sans-serif;
            font-size: 1.125rem;
        }
        body > h1 {
            background-image: url('img/pizzastock.jpg');
            background-size: 150% 100%;
            color: greenyellow;
            font-family: Georgia, 'Times New Roman', Times, serif;
            font-size: 3rem;
            font-style: italic;
            padding: 2rem;
            -webkit-text-stroke: .063rem black;
            stroke: .063rem black;
            paint-order: stroke fill;
        }
        .grey-box {
            background-color: #343541;
            margin: 1rem;
            padding: 0;
        }
        #chat h1::first-letter {
            text-transform: capitalize;
        }
        #chat h1, #chat h2 { font-size: 1.125rem }
        #chat > div {
            overflow: auto;
            padding: 0 1rem
        }
        #chat > div:nth-child(odd) { background-color: #444654 }
        #form {
            display: grid;
            grid-template-columns: 1fr 3rem;
            height: 3rem;
        }
        #form input {
            border-radius: 0;
            padding: 0 0 0 .5rem;
        }
        #message { min-width: 0 }
        #send { background-color: firebrick }
        #send svg {
            height: 1.75rem;
            position: relative;
            top: .125rem;
        }
        #typing span {
            animation: blink 1.5s infinite;
            opacity: 0;
        }
        #typing span:nth-child(2) { animation-delay: .5s }
        #typing span:nth-child(3) { animation-delay: 1s }
        @keyframes blink {
            0% {
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            100% {
                opacity: 0;
            }
        }
        .display-none { display: none }
    </style>
</head>
<body>
    <h1>MatGPT</h1>
    <main>
        <div class="grey-box">
            <div id="chat">
                <div id="typing">
                    <p><span>.</span><span>.</span><span>.</span></p>
                </div>
            </div>
            <form id="form">
                <input id="message" placeholder="Skriv ett meddelande" type="text">
                <button id="send" type="submit">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M310.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-192 192c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L242.7 256 73.4 86.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l192 192z"/></svg>
                </button>
            </form>
        </div>
    </main>
    <script type="module">
        /* printf equivalent https://stackoverflow.com/a/4673436 */
        if (!String.format) {
            String.format = function(format) {
                var args = Array.prototype.slice.call(arguments, 1);
                return format.replace(/{(\d+)}/g, function(match, number) {
                    return typeof args[number] != 'undefined' ? args[number] : match;
                });
            };
        }

        // const Adjectives = await fetch('./adjectives.json')
        //     .then((data) => { return data.json() });
        const Adjectives = await fetch('https://najls.github.io/matgpt/adjectives.json')
            .then((data) => { return data.json() });
        const adjectives = Adjectives.adjectives;

        // const Affirmations = await fetch('./affirmations.json')
        //     .then((data) => { return data.json() });
        const Affirmations = await fetch('https://najls.github.io/matgpt/affirmations.json')
            .then((data) => { return data.json() });
        const affirmations = Affirmations.affirmations;

        // const Adverbs = await fetch('./adverbs.json')
        //     .then((data) => { return data.json() });
        const Adverbs = await fetch('https://najls.github.io/matgpt/adverbs.json')
            .then((data) => { return data.json() });
        const adverbs = Adverbs.adverbs;

        // const Containers = await fetch('./containers.json')
        //     .then((data) => { return data.json() });
        const Containers = await fetch('https://najls.github.io/matgpt/containers.json')
            .then((data) => { return data.json() });
        const containers = Containers.containers;

        // const Greetings = await fetch('./greetings.json')
        //     .then((data) => { return data.json() });
        const Greetings = await fetch('https://najls.github.io/matgpt/greetings.json')
            .then((data) => { return data.json() });
        const greetings = Greetings.greetings;

        // const Ingredients = await fetch('./ingredients.json')
        //     .then((data) => { return data.json() });
        const Ingredients = await fetch('https://najls.github.io/matgpt/ingredients.json')
            .then((data) => { return data.json() });
        const ingredients = Ingredients.ingredients;

        // const Names = await fetch('./names.json')
        //     .then((data) => { return data.json() });
        const Names = await fetch('https://najls.github.io/matgpt/names.json')
            .then((data) => { return data.json() });
        const names = Names.names;

        // const Preambles = await fetch('./preambles.json')
        //     .then((data) => { return data.json() });
        const Preambles = await fetch('https://najls.github.io/matgpt/preambles.json')
            .then((data) => { return data.json() });
        const preambles = Preambles.preambles;

        // const Sentences = await fetch('./sentences.json')
        //     .then((data) => { return data.json() });
        const Sentences = await fetch('https://najls.github.io/matgpt/sentences.json')
            .then((data) => { return data.json() });
        const sentences = Sentences.sentences;

        // const Tools = await fetch('./tools.json')
        //     .then((data) => { return data.json() });
        const Tools = await fetch('https://najls.github.io/matgpt/tools.json')
            .then((data) => { return data.json() });
        const tools = Tools.tools;

        // const Units = await fetch('./units.json')
        //     .then((data) => { return data.json() });
        const Units = await fetch('https://najls.github.io/matgpt/units.json')
            .then((data) => { return data.json() });
        const units = Units.units;

        // const Verbs = await fetch('./verbs.json')
        //     .then((data) => { return data.json() });
        const Verbs = await fetch('https://najls.github.io/matgpt/verbs.json')
            .then((data) => { return data.json() });
        const verbs = Verbs.verbs;

        const pronouns = [
            'den',
            'det'
        ];

        // component enum
        const compType = Object.freeze({
            adjective: 0,
            adverb: 1,
            container: 2,
            ingredient: 3,
            pronoun: 4,
            tool: 5,
            unit: 6,
            verb: 7
        });

        const compTypeArr = [
            adjectives,
            adverbs,
            containers,
            ingredients,
            pronouns,
            tools,
            units,
            verbs
        ];

        /* get data from json file */
        async function getData(url) {
            const response = await fetch(url);
            return response.json();
        }

        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min) + min);
        }

        /* https://stackoverflow.com/a/29325222 */
        function getBiasedRandomInt(min, max, bias, influence) {
            let random = Math.random() * (max - min) + min,
            mix = Math.random() * influence;
            return Math.floor(random * (1 - mix) + bias * mix);
        }

        function truncCauchyDistrib(min, max, median, scale) {
            const cdf = (x, m, s) => {
                return(Math.atan((x - m) / s) / Math.PI + 0.5);
            };

            const rand = (a0, ad, m, s) => {
                const u = Math.random(),
                f0 = cdf(a0, m, s),
                fd = cdf(ad, m, s) - f0;

                return(m + s * Math.tan(Math.PI * (fd * u + f0 - 0.5)));
            };

            return Math.floor(rand(min, max, median, scale));
        }

        function getName(ingArr) {
            let name = names[getRandomInt(0, names.length)],
            components = [],
            componentStrings = [];

            for (let i = 0; i < name.components.length; i++) {
                let type = name.components[i],
                compArr,
                comp;

                if (type === compType.ingredient) {
                    for (let j = 0; j < ingArr.length; j++) {
                        comp = ingArr[j];

                        if (components.indexOf(comp) === -1 || j === ingArr.length - 1) {
                            components.push(comp);
                            break;
                        }
                    }
                }
                else {
                    compArr = compTypeArr[type];

                    while (components.indexOf(comp) === -1) { // loops infinitely if name.components contains more of one type than the corresponding component type array
                        comp = compArr[getRandomInt(0, compArr.length)];

                        if (components.indexOf(comp) === -1) components.push(comp);
                        else comp = null;
                    }
                }
            }

            for (let i = 0; i < name.components.length; i++) {
                let type = name.components[i],
                compStr;

                if (type === compType.ingredient) {
                    compStr = name.compound[i] && components[i].data.compound ? components[i].data.compound : components[i].data.indefinite[0];
                }
                else {
                    if (name.components[i + 1] === compType.ingredient) {
                        compStr = components[i][components[i + 1].data.ngen ? 'ngen' : 'tgen'];
                        components[i + 1].predestination = components[i + 1].quantity === 1 || !components[i + 1].data.unit ? compStr : components[i].plural;
                    }
                    else {
                        compStr = components[i].ngen;
                    }
                }
                componentStrings.push(compStr);
            }

            return String.format(name.base, ...componentStrings);
        }

        async function greet() {
            await new Promise(r => setTimeout(r, 1000));
            let content = document.createElement('div');
            let text = document.createElement('p');
            text.textContent = greetings[getRandomInt(0, greetings.length)];
            content.appendChild(text);
            document.getElementById('typing').classList.add('display-none');
            addElemToChat(content);
        }

        async function respond() {
            document.getElementById('typing').classList.remove('display-none');
            await new Promise(r => setTimeout(r, getRandomInt(20, 60) * 100));
            let content = document.createElement('div');
            let ingredientCount = getRandomInt(3, 7);
            let preambleElem = document.createElement('p');
            let recipeElem = document.createElement('article');
            let nameElem = document.createElement('h1');
            let ingredientsElem = document.createElement('ul');

            let ingredientArr = [];
            ingredients.sort(() => .5 - Math.random()).slice(0, ingredientCount).forEach(ingredient => ingredientArr.push(new Ingredient(ingredient)));

            let name = getName(ingredientArr);
            let preamble = String.format(preambles[getRandomInt(0, preambles.length)], name);

            ingredientArr.forEach(ingredient => {
                let li = document.createElement('li');
                li.appendChild(document.createTextNode(`${ingredient.quantity} ${ingredient.unit} ${ingredient.name}`));
                ingredientsElem.appendChild(li);
            });

            preambleElem.appendChild(document.createTextNode(preamble));
            nameElem.appendChild(document.createTextNode(name));
            recipeElem.appendChild(preambleElem);
            recipeElem.appendChild(nameElem);
            recipeElem.appendChild(ingredientsElem);
            content.appendChild(recipeElem);
            document.getElementById('typing').classList.add('display-none');
            addElemToChat(content);
        }

        function addElemToChat(elem) {
            document.getElementById('chat').insertBefore(elem, document.getElementById('typing'));
            window.scrollTo(0, document.body.scrollHeight);
        }



        class Ingredient {
            constructor(data) {
                this.data = data;
                this.setQuantity();
                this.setUnit();
                this.setName();
                this.predestination = null;
            }

            setQuantity() {
                this.quantity = truncCauchyDistrib(1, 100, 2, 3);
            }

            setUnit() {
                let unitIndex = truncCauchyDistrib(0, units.length, units.length / 8, units.length / 4);
                this.unit = this.data.unit ? '' : this.quantity > 1 ? units[unitIndex].at(-1) : units[unitIndex][0];
            }

            setName() {
                this.name = this.quantity > 1 && this.data.unit ? this.data.indefinite[1] : this.data.indefinite[0];
            }
        }

        let message = document.getElementById('message');

        document.getElementById('form').addEventListener('submit', (e) => {
            e.preventDefault();

            if (message.value) {
                let content = document.createElement('div');
                let text = document.createElement('p');
                text.textContent = message.value;
                content.appendChild(text);
                message.value = '';
                addElemToChat(content);
                respond();
            }
        });

        greet();
    </script>
</body>
</html>